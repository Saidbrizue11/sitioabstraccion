<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actividad 2</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div>
        <h1>Actividad 2</h1>
        <p>Hola a todos, mi nombre es Carlos Said Rojas Cadena.Y yo les comentare sobre las estrcturas de datos y algunas estructuras que son importantes.</p>

        <h3>Que son las estructuras de datos</h3>
        <p>Las estructuras de datos son formas organizadas y eficientes de almacenar, gestionar y organizar datos en un programa de computadora. Estas estructuras proporcionan un marco para representar y manipular datos, lo que facilita la realización de operaciones como inserción, eliminación, búsqueda y ordenación de información. Las estructuras de datos incluyen tipos simples como números y caracteres, así como tipos más complejos como listas, pilas, colas, árboles y grafos, que se utilizan para resolver diversos problemas y optimizar el rendimiento de los programas. La elección adecuada de una estructura de datos depende de las necesidades específicas de cada aplicación y de los objetivos de eficiencia en el procesamiento de datos.</p>
        <div class="contenedor">
            <img src="https://media.istockphoto.com/id/1323937065/es/vector/devops-software-desarrollo-operaciones-s%C3%ADmbolo-infinito-concepto-de-desarrollo-web-en-dise%C3%B1o.jpg?s=612x612&w=0&k=20&c=VeXRh6hZ0yv4KExXzqGicJrGFLnyj4O7lJdAI_8Rgl8="></div>
    </div>
    <div>
        <h1>Tipo de Estructuras de Datos</h1>

        <h2>Pilas</h2>
        <p>Una pila es una estructura de datos lineal que sigue el principio "último en entrar, primero en salir" (LIFO). Se utiliza para almacenar elementos y permite dos operaciones principales: push (para agregar elementos) y pop (para quitar elementos).</p>
        <!--<link rel="Estructura de datos - Pilas " href="https://youtu.be/WN6O6t7vm9w"> -->
        <video width="768" height="480" controls>
            <source src="pilas.mp4" type="video/mp4">
        </video>
        <h3>Codigo usado</h3>
            <pre>
                #include < stdio.h>
                #include < stdlib.h>
                
                #define MAX_SIZE 10
                
                // Definición de la estructura de la pila
                typedef struct {
                    int data[MAX_SIZE];
                    int top;
                } Stack;
                
                // Función para inicializar una pila vacía
                void init(Stack *stack) {
                    stack->top = -1;
                }
                
                // Función para verificar si la pila está vacía
                int isEmpty(Stack *stack) {
                    return (stack->top == -1);
                }
                
                // Función para verificar si la pila está llena
                int isFull(Stack *stack) {
                    return (stack->top == MAX_SIZE - 1);
                }
                
                // Función para empujar (push) un elemento a la pila
                void push(Stack *stack, int value) {
                    if (isFull(stack)) {
                        printf("Error: la pila está llena, no se puede insertar más elementos.\n");
                        return;
                    }
                    stack->data[++(stack->top)] = value;
                }
                
                // Función para sacar (pop) un elemento de la pila
                int pop(Stack *stack) {
                    if (isEmpty(stack)) {
                        printf("Error: la pila esta vacia, no se puede sacar ningun elemento.\n");
                        return -1; // Valor especial para indicar un error
                    }
                    return stack->data[(stack->top)--];
                }
                
                int main() {
                    Stack stack;
                    init(&stack); // Inicializar la pila
                
                    int num, choice;
                    do {
                        printf("1. Push (Agregar numero)\n");
                        printf("2. Pop (Sacar numero)\n");
                        printf("3. Salir\n");
                        printf("Seleccione una opcion: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                if (stack.top < MAX_SIZE - 1) {
                                    printf("Ingrese un numero: ");
                                    scanf("%d", &num);
                                    push(&stack, num);
                                } else {
                                    printf("Error: la pila esta llena, no se puede insertar mas elementos.\n");
                                }
                                break;
                            case 2:
                                if (!isEmpty(&stack)) {
                                    int popped = pop(&stack);
                                    printf("Elemento sacado de la pila: %d\n", popped);
                                } else {
                                    printf("Error: la pila esta vacia, no se puede sacar ningun elemento.\n");
                                }
                                break;
                            case 3:
                                break;
                            default:
                                printf("Opcion no valida. Intentelo de nuevo.\n");
                        }
                    } while (choice != 3);
                    return 0;
                }
            </pre>

        <h2>Colas</h2>
        <p>Una cola es una estructura de datos lineal que sigue el principio "primero en entrar, primero en salir" (FIFO). Se utiliza para almacenar elementos y admite operaciones como enqueue (agregar elementos) y dequeue (quitar elementos).</p>
        <!-- -->
        
        <!-- <link rel="Estructura de datos - Colas " href="https://youtu.be/hu6HvDhxUrY">-->
        <video width="768" height="480" controls>
            <source src="cola.mp4" type="video/mp4">
        </video>
        <h3>Codigo usado</h3>
            <pre>
                #include < stdio.h>
                #include < stdlib.h>
                
                #define MAX_SIZE 10
                
                // Definición de la estructura de la cola
                typedef struct {
                    int data[MAX_SIZE];
                    int front;
                    int rear;
                } Queue;
                
                // Función para inicializar una cola vacía
                void init(Queue *queue) {
                    queue->front = -1;
                    queue->rear = -1;
                }
                
                // Función para verificar si la cola está vacía
                int isEmpty(Queue *queue) {
                    return (queue->front == -1);
                }
                
                // Función para verificar si la cola está llena
                int isFull(Queue *queue) {
                    return ((queue->rear + 1) % MAX_SIZE == queue->front);
                }
                
                // Función para encolar (enqueue) un elemento a la cola
                void enqueue(Queue *queue, int value) {
                    if (isFull(queue)) {
                        printf("Error: la cola está llena, no se puede insertar mas elementos.\n");
                        return;
                    }
                    if (isEmpty(queue)) {
                        queue->front = 0;
                        queue->rear = 0;
                    } else {
                        queue->rear = (queue->rear + 1) % MAX_SIZE;
                    }
                    queue->data[queue->rear] = value;
                }
                
                // Función para desencolar (dequeue) un elemento de la cola
                int dequeue(Queue *queue) {
                    if (isEmpty(queue)) {
                        printf("Error: la cola esta vacia, no se puede desencolar ningun elemento.\n");
                        return -1; // Valor especial para indicar un error
                    }
                    int value = queue->data[queue->front];
                    if (queue->front == queue->rear) {
                        // Si solo hay un elemento en la cola, reiniciamos los índices
                        queue->front = -1;
                        queue->rear = -1;
                    } else {
                        queue->front = (queue->front + 1) % MAX_SIZE;
                    }
                    return value;
                }
                
                int main() {
                    Queue queue;
                    init(&queue); // Inicializar la cola
                
                    int num, choice;
                    do {
                        printf("1. Enqueue (Agregar numero)\n");
                        printf("2. Dequeue (Sacar numero)\n");
                        printf("3. Salir\n");
                        printf("Seleccione una opcion: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                if (!isFull(&queue)) {
                                    printf("Ingrese un numero: ");
                                    scanf("%d", &num);
                                    enqueue(&queue, num);
                                } else {
                                    printf("Error: la cola esta llena, no se puede insertar mas elementos.\n");
                                }
                                break;
                            case 2:
                                if (!isEmpty(&queue)) {
                                    int dequeued = dequeue(&queue);
                                    printf("Elemento sacado de la cola: %d\n", dequeued);
                                } else {
                                    printf("Error: la cola esta vacia, no se puede desencolar ningun elemento.\n");
                                }
                                break;
                            case 3:
                                break;
                            default:
                                printf("Opcion no valida. Intentelo de nuevo.\n");
                        }
                    } while (choice != 3);
                
                    return 0;
                }
                
            </pre>

        <h2>Listas</h2>
        <p>Una lista es una estructura de datos que permite almacenar una colección ordenada de elementos. Puede ser una lista enlazada o una lista de elementos contiguos en la memoria.</p>
        <!-- <link rel="Estructura de datos - Listas " href="https://youtu.be/t11FN4FPlDw">-->
        <video width="768" height="480" controls>
            <source src="lista.mp4" type="video/mp4">
        </video>
        <h3>Codigo usado</h3>
            <pre>
                #include < stdio.h>
                #include < stdlib.h>
                
                // Definición de la estructura de un nodo en la lista
                typedef struct Node {
                    int data;
                    struct Node* next;
                } Node;
                
                // Función para crear un nuevo nodo
                Node* createNode(int value) {
                    Node* newNode = (Node*)malloc(sizeof(Node));
                    if (newNode == NULL) {
                        printf("Error: No se pudo asignar memoria para el nuevo nodo.\n");
                        exit(1);
                    }
                    newNode->data = value;
                    newNode->next = NULL;
                    return newNode;
                }
                
                // Función para insertar un nodo al final de la lista
                Node* insert(Node* head, int value) {
                    Node* newNode = createNode(value);
                    if (head == NULL) {
                        return newNode;
                    }
                    Node* current = head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newNode;
                    return head;
                }
                
                // Función para imprimir la lista
                void printList(Node* head) {
                    Node* current = head;
                    while (current != NULL) {
                        printf("%d -> ", current->data);
                        current = current->next;
                    }
                    printf("NULL\n");
                }
                
                int main() {
                    Node* head = NULL;
                
                    int num, choice;
                    do {
                        printf("1. Insertar un numero\n");
                        printf("2. Imprimir la lista\n");
                        printf("3. Salir\n");
                        printf("Seleccione una opcion: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Ingrese un numero: ");
                                scanf("%d", &num);
                                head = insert(head, num);
                                break;
                            case 2:
                                printf("Lista: ");
                                printList(head);
                                break;
                            case 3:
                                break;
                            default:
                                printf("Opcion no valida. Intentelo de nuevo.\n");
                        }
                    } while (choice != 3);
                
                    // Liberar la memoria asignada para la lista
                    while (head != NULL) {
                        Node* temp = head;
                        head = head->next;
                        free(temp);
                    }
                
                    return 0;
                }
                
            </pre>

        <h2>Árboles</h2>
        <p>Un árbol es una estructura de datos jerárquica que consta de nodos conectados por aristas. Cada nodo puede tener cero o más nodos hijos, y hay un nodo raíz.</p>
        <!-- <link rel="Estructura de datos - Arboles " href="https://youtu.be/0jxPBrsGG7I">-->
        <video width="768" height="480" controls>
            <source src="arbol.mp4" type="video/mp4">
        </video>
        <h3>Codigo usado</h3>
            <pre>
                #include < stdio.h>
                #include < stdlib.h>
                
                // Definición de la estructura del nodo de un árbol binario
                typedef struct TreeNode {
                    int data;
                    struct TreeNode* left;
                    struct TreeNode* right;
                } TreeNode;
                
                // Función para crear un nuevo nodo del árbol
                TreeNode* createNode(int value) {
                    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                    if (newNode == NULL) {
                        printf("Error: No se pudo asignar memoria para el nuevo nodo.\n");
                        exit(1);
                    }
                    newNode->data = value;
                    newNode->left = NULL;
                    newNode->right = NULL;
                    return newNode;
                }
                
                // Función para insertar un valor en un árbol binario de búsqueda
                TreeNode* insert(TreeNode* root, int value) {
                    if (root == NULL) {
                        return createNode(value);
                    }
                    if (value < root->data) {
                        root->left = insert(root->left, value);
                    } else if (value > root->data) {
                        root->right = insert(root->right, value);
                    }
                    return root;
                }
                
                // Función para realizar un recorrido inorden (inorder traversal) del árbol
                void inorderTraversal(TreeNode* root) {
                    if (root != NULL) {
                        inorderTraversal(root->left);
                        printf("%d ", root->data);
                        inorderTraversal(root->right);
                    }
                }
                
                int main() {
                    TreeNode* root = NULL;
                
                    int num, choice;
                    do {
                        printf("1. Insertar un numero\n");
                        printf("2. Realizar recorrido inorden\n");
                        printf("3. Salir\n");
                        printf("Seleccione una opcion: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Ingrese un numero: ");
                                scanf("%d", &num);
                                root = insert(root, num);
                                break;
                            case 2:
                                printf("Recorrido inorden: ");
                                inorderTraversal(root);
                                printf("\n");
                                break;
                            case 3:
                                break;
                            default:
                                printf("Opción no valida. Intentelo de nuevo.\n");
                        }
                    } while (choice != 3);
                
                    return 0;
                }
                
            </pre>

        <h2>Grafos</h2>
        <p>Un grafo es una estructura de datos que consta de nodos (vértices) y aristas (conexiones) que conectan los nodos. Los grafos pueden ser dirigidos o no dirigidos.</p>
        <!-- <link rel="Estructura de datos - Grafos " href="https://youtu.be/diYnG6wHQbc">-->
        <video width="768" height="480" controls>
            <source src="grafos.mp4" type="video/mp4">
        </video>
        <h3>Codigo usado</h3>
            <pre>
                #include < stdio.h>
                #include < stdlib.h>
                
                // Definición de la estructura del grafo
                typedef struct {
                    int V;          // Número de vértices
                    int** adjMatrix; // Matriz de adyacencia
                } Graph;
                
                // Función para crear un grafo con V vértices
                Graph* createGraph(int V) {
                    Graph* graph = (Graph*)malloc(sizeof(Graph));
                    if (graph == NULL) {
                        printf("Error: No se pudo asignar memoria para el grafo.\n");
                        exit(1);
                    }
                    graph->V = V;
                
                    // Crear una matriz VxV e inicializarla con ceros
                    graph->adjMatrix = (int**)malloc(V * sizeof(int*));
                    if (graph->adjMatrix == NULL) {
                        printf("Error: No se pudo asignar memoria para la matriz de adyacencia.\n");
                        exit(1);
                    }
                    for (int i = 0; i < V; i++) {
                        graph->adjMatrix[i] = (int*)malloc(V * sizeof(int));
                        if (graph->adjMatrix[i] == NULL) {
                            printf("Error: No se pudo asignar memoria para la matriz de adyacencia.\n");
                            exit(1);
                        }
                        for (int j = 0; j < V; j++) {
                            graph->adjMatrix[i][j] = 0;
                        }
                    }
                    return graph;
                }
                
                // Función para agregar una arista (conexión) al grafo
                void addEdge(Graph* graph, int src, int dest) {
                    // Marcar la conexión como 1 en la matriz de adyacencia
                    graph->adjMatrix[src][dest] = 1;
                    // Si el grafo es no dirigido, descomenta la siguiente línea para marcar la conexión en ambas direcciones
                    // graph->adjMatrix[dest][src] = 1;
                }
                
                // Función para mostrar el grafo en forma de matriz de adyacencia
                void printGraph(Graph* graph) {
                    printf("Matriz de adyacencia del grafo:\n");
                    for (int i = 0; i < graph->V; i++) {
                        for (int j = 0; j < graph->V; j++) {
                            printf("%d ", graph->adjMatrix[i][j]);
                        }
                        printf("\n");
                    }
                }
                
                int main() {
                    int V = 5; // Número de vértices del grafo
                    Graph* graph = createGraph(V);
                
                    // Agregar aristas al grafo
                    addEdge(graph, 0, 1);
                    addEdge(graph, 0, 4);
                    addEdge(graph, 1, 2);
                    addEdge(graph, 1, 3);
                    addEdge(graph, 2, 3);
                
                    // Mostrar el grafo en forma de matriz de adyacencia
                    printGraph(graph);
                
                    // Liberar memoria asignada para el grafo y la matriz de adyacencia
                    for (int i = 0; i < V; i++) {
                        free(graph->adjMatrix[i]);
                    }
                    free(graph->adjMatrix);
                    free(graph);
                    return 0;
                }
                
            </pre>

        </div>
</body>
</html>